{"version":3,"sources":["../src/credentialstore/osx/osx-keychain-parser.js"],"names":[],"mappings":"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","file":"osx-keychain-parser.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n*  Copyright (c) Microsoft Corporation. All rights reserved.\r\n*  Licensed under the MIT License. See License.txt in the project root for license information.\r\n*--------------------------------------------------------------------------------------------*/\r\n'use strict';\r\n\r\n//\r\n// Parser for the output of the security(1) command line.\r\n//\r\n\r\nvar _ = require('underscore');\r\nvar es = require('event-stream');\r\nvar stream = require('readable-stream');\r\nvar util = require('util');\r\n\r\n//\r\n// Regular expressions that match the various fields in the input\r\n//\r\n\r\n// Fields at the root - not attributes\r\nvar rootFieldRe = /^([^:]+):(?: (?:\"([^\"]+)\")|(.*))?$/;\r\n\r\n// Attribute values, this gets a little more complicated\r\nvar attrRe = /^    (?:(0x[0-9a-fA-F]+) |\"([a-z]{4})\")<[^>]+>=(?:(<NULL>)|\"([^\"]+)\"|(0x[0-9a-fA-F]+)(?:  \"([^\"]+)\")|(.*)?)/;\r\n\r\n//\r\n// Stream based parser for the OSX security(1) program output.\r\n// Implements a simple state machine. States are:\r\n//\r\n//   0 - Waiting for the initial \"keychain\" string.\r\n//   1 - Waiting for the \"attributes\" string. adds any properties to the\r\n//       current entry object being parsed while waiting.\r\n//   2 - reading attributes. Continues adding the attributes to the\r\n//       current entry object until we hit either a non-indented line\r\n//       or end. At which point we emit.\r\n//\r\n\r\nvar Transform = stream.Transform;\r\n\r\nfunction OsxSecurityParsingStream() {\r\n  Transform.call(this, {\r\n    objectMode: true\r\n  });\r\n\r\n  this.currentEntry = null;\r\n  this.state = 0;\r\n}\r\n\r\nutil.inherits(OsxSecurityParsingStream, Transform);\r\n\r\n_.extend(OsxSecurityParsingStream.prototype, {\r\n  _transform: function (chunk, encoding, callback) {\r\n    var match;\r\n    var value;\r\n    var line = chunk.toString();\r\n    var count = 0;\r\n\r\n    while (line !== null && line !== '') {\r\n      ++count;\r\n      if (count > 2) {\r\n        return callback(new Error('Multiple passes attempting to parse line [' + line + ']. Possible bug in parser and infinite loop'));\r\n      }\r\n\r\n      switch(this.state) {\r\n        case 0:\r\n          match = rootFieldRe.exec(line);\r\n          if (match !== null) {\r\n            if (match[1] === 'keychain') {\r\n              this.currentEntry = {\r\n                keychain: match[2]\r\n              };\r\n              this.state = 1;\r\n              line = null;\r\n            } else {\r\n              this.currentEntry[match[1]] = match[2] || match[3];\r\n            }\r\n          }\r\n\r\n          break;\r\n\r\n        case 1:\r\n          match = rootFieldRe.exec(line);\r\n          if (match !== null) {\r\n            if (match[1] !== 'attributes') {\r\n              this.currentEntry[match[1]] = match[2];\r\n              line = null;\r\n            } else {\r\n              this.state = 2;\r\n              line = null;\r\n            }\r\n          }\r\n          break;\r\n\r\n        case 2:\r\n          match = attrRe.exec(line);\r\n          if (match !== null) {\r\n            // Did we match a four-char named field? We don't care about hex fields\r\n            if (match[2]) {\r\n              // We skip nulls, and grab text rather than hex encoded versions of value\r\n              value = match[6] || match[4];\r\n              if (value) {\r\n                this.currentEntry[match[2]] = value;\r\n              }\r\n            }\r\n            line = null;\r\n          } else {\r\n            // Didn't match, so emit current entry, then\r\n            // reset to state zero and start processing for the\r\n            // next entry.\r\n            this.push(this.currentEntry);\r\n            this.currentEntry = null;\r\n            this.state = 0;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    callback();\r\n  },\r\n\r\n  _flush: function (callback) {\r\n    if (this.currentEntry) {\r\n      this.push(this.currentEntry);\r\n    }\r\n    callback();\r\n  }\r\n});\r\n\r\nfunction createParsingStream() {\r\n  return es.pipeline(es.split(), new OsxSecurityParsingStream());\r\n}\r\n\r\ncreateParsingStream.ParsingStream = OsxSecurityParsingStream;\r\n\r\nmodule.exports = createParsingStream;\r\n"],"sourceRoot":"C:\\Users\\jorit\\Desktop\\vsts-vscode\\out"}